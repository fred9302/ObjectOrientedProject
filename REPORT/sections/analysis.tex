\chapter{Analysis}\label{ch:Analysis}

In the first step of the waterfall model, requirement and object analysis is carried out.

\section{Defining use cases}
Based on the description given, actors and use cases are identified and then clearly defined.

\subsection{Actors}
Based on the project description provided, the only actor that we have found would be the user who is running the simulation. At first we had considered the database to be an actor of the system but later discovered that it would not be that appropriate to have the database as an actor to the system.

\subsection{Use cases}
Next, we have defined the various use cases that we want the user to be able to do, which will be described in the following sections.

\subsubsection{Add node}
When the user wants to add the node, they would need to specify the type of node added. The node added could be either a IoT Node or a network gateway.

\subsubsection{Start Simulation}
When the user wants to start the simulation, they would need to provide the following information:
\begin{itemize}
  \item Number of nodes in the network
  \item Size of the 2D grid where the nodes will be placed
  \item Option of verbose output
\end{itemize}

\subsubsection{See simulation statistics}
When the user wants to see simulation statistics, the system would need to check if any simulation has occurred previously. If there is no prior simulation, then the system would display an error. Otherwise, the system would display the simulation statistics such as throughput, delay, and packet loss.

\subsection{Use case diagram}
Based on the factors mentioned above, a use case diagram was developed. The use case diagram can be seen below.

\subsection{FURPS}

The FURPS were utilized to better define the system's requirements. The system's overall summary was also created using this technique. This approach also aided in providing a fresh and more enlightening perspective on the issue and the requirements.

\subsubsection{Functionality: what should the system do?}
\begin{itemize}
  \item The system should be able to place the nodes in a grid and transmit packets from one node to the gateway.

        %\item The system would need to place different type of nodes in the network

  \item The system would need to run the simulation for a fixed amount of time


\end{itemize}

\subsubsection{Usability: what kind of UI is needed?}
\begin{itemize}
  \item A screen would be required to display the simulation statistics
  \item A device should receive user input eg.keyboard
\end{itemize}

\subsubsection{Reliability: what is the tolerance of the system to failures?}
\begin{itemize}
  \item The system should be able to check if the simulation has been run before displaying simulation statistics
\end{itemize}

\subsubsection{Performance: which response times, accuracy, availability, resource usage should the system have?}

\begin{itemize}
  \item The GUI needs to be run on a simple computer
  \item The simulation statistics needs to be stored in a server
\end{itemize}

\subsubsection{Sustainability: what adaptations may be needed?}
\begin{itemize}
  \item The system need to give the user the ability to change the simulation conditions after a run has been completed
\end{itemize}

\section{Domain model}
To aid the group in identifying the various objects involved in the problem, a domain model was developed. Firstly, the identified actor, which is the user, is represented as a GUI in the model. This also constitutes the front end of the system. Regarding the back end of the system, we would need one object to simulate the network and another one to generate/store the simulation statistics. Ultimately, we would need an object for the devices themselves and one for the overall network. Here it might also be a viable option to differentiate between a node object and a gateway object that then both can inherit attributes and methods from the device object when making the class diagram. Then, in order to control everything and tie the simulation to gather, it would make sense to incorporate a simulation object that handles the simulation itself.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{Domain_model.pdf}
  \caption{Diagram of the domain model.}
  \label{fig:Domain_model}
\end{figure}

\section{Class diagram}
The entirety of the class diagram can be seen in \autoref{fig:Class_diagram}. The parts that were not implemented have their text colored red. This also implies that the class diagram is made in accordance to how the implementation has been done

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{UML class diagram.pdf}
  \caption{Diagram of the classes.}
  \label{fig:Class_diagram}
\end{figure}


\subsection{GUI}


\subsection{Simulation}


\subsection{Network}


\subsection{Device}


\subsubsection{Node}


\subsubsection{Gateway}




